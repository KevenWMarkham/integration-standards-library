/**
 * ISL Implementation Accelerator â€” Azure API Management Adapter
 * Maps ISL-01 (API Governance) to APIM policies and catalog.
 */
(function() {
class ApimAdapter {
  constructor(config) {
    this._config = config;
    this._adapterConfig = config.adapters?.config?.apim || {};
  }

  static getId() { return 'apim'; }
  static getName() { return 'Azure API Management'; }
  static getDescription() { return 'Generates APIM naming policies, versioning rules, security policies, and API catalog templates.'; }
  static getModules() { return ['ISL-01']; }

  validate() {
    const errors = [];
    if (!this._config.naming?.orgPrefix) errors.push('naming.orgPrefix is required for API naming policies');
    return { valid: errors.length === 0, errors };
  }

  getConfigFields() {
    return [
      { key: 'versioningStrategy', type: 'select', label: 'Versioning Strategy', options: ['url-path', 'query-param', 'header'], default: 'url-path', required: false },
      { key: 'authMethod', type: 'select', label: 'Auth Method', options: ['oauth2', 'api-key', 'certificate', 'oauth2-and-key'], default: 'oauth2', required: false },
      { key: 'rateLimitDefault', type: 'number', label: 'Default Rate Limit', description: 'Requests per minute', default: 1000, required: false },
      { key: 'mTlsRequired', type: 'boolean', label: 'Mutual TLS', default: false, required: false },
      { key: 'apimInstanceName', type: 'string', label: 'APIM Instance', description: 'Azure APIM instance name', required: false },
      { key: 'resourceGroup', type: 'string', label: 'Resource Group', required: false }
    ];
  }

  transform(templates, config) {
    const prefix = this._config.naming?.orgPrefix || 'org';
    const auth = this._adapterConfig.authMethod || 'oauth2';
    const rateLimit = this._adapterConfig.rateLimitDefault || 1000;
    const versioning = this._adapterConfig.versioningStrategy || 'url-path';

    // Naming policy XML
    const namingPolicyXml = `<!--
  ISL-01 API Naming Convention Policy
  Generated by ISL Implementation Accelerator
  Enforces: kebab-case resource names, plural nouns, version prefix
-->
<policies>
  <inbound>
    <base />
    <!-- Enforce URL path conventions -->
    <set-variable name="requestPath" value="@(context.Request.Url.Path)" />
    <choose>
      <!-- Block paths with uppercase characters -->
      <when condition="@(System.Text.RegularExpressions.Regex.IsMatch(context.Request.Url.Path, &quot;[A-Z]&quot;))">
        <return-response>
          <set-status code="400" reason="Bad Request" />
          <set-body>{"error":"API paths must use lowercase kebab-case per ${prefix.toUpperCase()} API naming standards"}</set-body>
        </return-response>
      </when>
      <!-- Block paths with underscores -->
      <when condition="@(context.Request.Url.Path.Contains(&quot;_&quot;))">
        <return-response>
          <set-status code="400" reason="Bad Request" />
          <set-body>{"error":"API paths must use hyphens, not underscores, per ${prefix.toUpperCase()} API naming standards"}</set-body>
        </return-response>
      </when>
    </choose>
  </inbound>
  <backend><base /></backend>
  <outbound><base /></outbound>
  <on-error><base /></on-error>
</policies>`;

    // Versioning policy XML
    const versioningPolicyXml = `<!--
  ISL-01 API Versioning Policy (${versioning})
  Generated by ISL Implementation Accelerator
-->
<policies>
  <inbound>
    <base />${versioning === 'url-path' ? `
    <!-- URL path versioning: /v1/resources, /v2/resources -->
    <set-variable name="apiVersion" value="@{
      var path = context.Request.Url.Path;
      var match = System.Text.RegularExpressions.Regex.Match(path, @"/v(\\d+)/");
      return match.Success ? match.Groups[1].Value : "1";
    }" />
    <choose>
      <when condition="@(!System.Text.RegularExpressions.Regex.IsMatch(context.Request.Url.Path, @&quot;^/v\\d+/&quot;))">
        <return-response>
          <set-status code="400" reason="Bad Request" />
          <set-body>{"error":"API version prefix required (e.g., /v1/) per ${prefix.toUpperCase()} versioning standards"}</set-body>
        </return-response>
      </when>
    </choose>` : versioning === 'query-param' ? `
    <!-- Query parameter versioning: ?api-version=1.0 -->
    <set-variable name="apiVersion" value="@(context.Request.Url.Query.GetValueOrDefault("api-version", "1.0"))" />
    <choose>
      <when condition="@(!context.Request.Url.Query.ContainsKey(&quot;api-version&quot;))">
        <return-response>
          <set-status code="400" reason="Bad Request" />
          <set-body>{"error":"api-version query parameter required per ${prefix.toUpperCase()} versioning standards"}</set-body>
        </return-response>
      </when>
    </choose>` : `
    <!-- Header versioning: X-API-Version: 1.0 -->
    <set-variable name="apiVersion" value="@(context.Request.Headers.GetValueOrDefault("X-API-Version", "1.0"))" />`}
    <set-header name="X-API-Version" exists-action="override">
      <value>@((string)context.Variables["apiVersion"])</value>
    </set-header>
  </inbound>
  <backend><base /></backend>
  <outbound>
    <base />
    <set-header name="X-API-Version" exists-action="override">
      <value>@((string)context.Variables["apiVersion"])</value>
    </set-header>
  </outbound>
  <on-error><base /></on-error>
</policies>`;

    // Security policy XML
    const securityPolicyXml = `<!--
  ISL-01 API Security Policy
  Auth: ${auth} | Rate Limit: ${rateLimit}/min | mTLS: ${this._adapterConfig.mTlsRequired || false}
  Generated by ISL Implementation Accelerator
-->
<policies>
  <inbound>
    <base />${auth.includes('oauth2') ? `
    <!-- OAuth 2.0 JWT Validation -->
    <validate-jwt header-name="Authorization" failed-validation-httpcode="401" failed-validation-error-message="Unauthorized - Valid OAuth2 token required per ${prefix.toUpperCase()} API security standards">
      <openid-config url="https://login.microsoftonline.com/{tenant-id}/v2.0/.well-known/openid-configuration" />
      <required-claims>
        <claim name="aud" match="all">
          <value>{api-client-id}</value>
        </claim>
      </required-claims>
    </validate-jwt>` : ''}${auth.includes('key') ? `
    <!-- API Key Validation -->
    <check-header name="Ocp-Apim-Subscription-Key" failed-check-httpcode="401" failed-check-error-message="API key required" ignore-case="false" />` : ''}${this._adapterConfig.mTlsRequired ? `
    <!-- Mutual TLS Certificate Validation -->
    <choose>
      <when condition="@(context.Request.Certificate == null)">
        <return-response>
          <set-status code="403" reason="Forbidden" />
          <set-body>{"error":"Client certificate required per ${prefix.toUpperCase()} mTLS policy"}</set-body>
        </return-response>
      </when>
    </choose>` : ''}
    <!-- Rate Limiting -->
    <rate-limit-by-key calls="${rateLimit}" renewal-period="60" counter-key="@(context.Subscription?.Key ?? context.Request.IpAddress)" />
    <!-- CORS -->
    <cors allow-credentials="false">
      <allowed-origins><origin>*</origin></allowed-origins>
      <allowed-methods><method>GET</method><method>POST</method><method>PUT</method><method>PATCH</method><method>DELETE</method><method>OPTIONS</method></allowed-methods>
      <allowed-headers><header>Content-Type</header><header>Authorization</header><header>X-API-Version</header></allowed-headers>
    </cors>
  </inbound>
  <backend><base /></backend>
  <outbound>
    <base />
    <set-header name="X-Content-Type-Options" exists-action="override"><value>nosniff</value></set-header>
    <set-header name="X-Frame-Options" exists-action="override"><value>DENY</value></set-header>
    <set-header name="Strict-Transport-Security" exists-action="override"><value>max-age=31536000; includeSubDomains</value></set-header>
  </outbound>
  <on-error><base /></on-error>
</policies>`;

    // API catalog template
    const apiCatalog = {
      clientName: this._config.clientName,
      generatedAt: new Date().toISOString(),
      namingStandard: { pattern: '/v{version}/{resource-plural}', casing: 'kebab-case', pluralNouns: true, versioningStrategy: versioning },
      lifecycleStates: ['draft', 'review', 'published', 'deprecated', 'retired'],
      securityProfile: { authMethod: auth, rateLimit, mTlsRequired: this._adapterConfig.mTlsRequired || false },
      apiTemplates: [
        { name: 'Standard CRUD API', pattern: '/v1/{resources}', methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'], securityLevel: 'Internal' },
        { name: 'Read-Only API', pattern: '/v1/{resources}', methods: ['GET'], securityLevel: 'Internal' },
        { name: 'Public API', pattern: '/v1/{resources}', methods: ['GET'], securityLevel: 'Public' },
        { name: 'Admin API', pattern: '/v1/admin/{resources}', methods: ['GET', 'POST', 'PUT', 'DELETE'], securityLevel: 'Restricted' }
      ]
    };

    return {
      configs: [
        { name: 'naming-policy.xml', content: namingPolicyXml },
        { name: 'versioning-policy.xml', content: versioningPolicyXml },
        { name: 'security-policy.xml', content: securityPolicyXml },
        { name: 'api-catalog.json', content: JSON.stringify(apiCatalog, null, 2) }
      ],
      docs: [{ name: 'apim-deployment-guide.md', content: this._generateGuide(apiCatalog) }],
      scripts: []
    };
  }

  generateScripts() {
    const apimName = this._adapterConfig.apimInstanceName || '<APIM_INSTANCE_NAME>';
    const rg = this._adapterConfig.resourceGroup || '<RESOURCE_GROUP>';
    const ps1 = `<#
.SYNOPSIS
    Deploy APIM policies from ISL API governance standards.
.PARAMETER ApimName
    Azure API Management instance name
.PARAMETER ResourceGroup
    Azure resource group
.PARAMETER WhatIf
    Preview changes without applying
#>
[CmdletBinding(SupportsShouldProcess)]
param(
    [string]$ApimName = "${apimName}",
    [string]$ResourceGroup = "${rg}",
    [string]$PolicyPath = ".\\configs"
)

$ErrorActionPreference = "Stop"

Write-Host "=== ISL APIM Policy Deployment ===" -ForegroundColor Cyan
Write-Host "Instance: $ApimName | Resource Group: $ResourceGroup" -ForegroundColor Green

# Import Az.ApiManagement
Import-Module Az.ApiManagement -ErrorAction Stop

# Get APIM context
$ctx = New-AzApiManagementContext -ResourceGroupName $ResourceGroup -ServiceName $ApimName

# Deploy global policies
$policyFiles = @(
    @{ Name="naming-policy.xml"; Scope="Global"; Description="API naming conventions" },
    @{ Name="security-policy.xml"; Scope="Global"; Description="Security standards" }
)

foreach ($pf in $policyFiles) {
    $filePath = Join-Path $PolicyPath $pf.Name
    if (Test-Path $filePath) {
        if ($PSCmdlet.ShouldProcess($pf.Name, "Apply $($pf.Scope) policy")) {
            $content = Get-Content $filePath -Raw
            Set-AzApiManagementPolicy -Context $ctx -Policy $content
            Write-Host "  APPLIED: $($pf.Description)" -ForegroundColor Green
        }
    } else {
        Write-Host "  SKIP: $filePath not found" -ForegroundColor DarkYellow
    }
}

Write-Host ""
Write-Host "=== Deployment Complete ===" -ForegroundColor Cyan
Write-Host "Review policies in Azure Portal > API Management > Policies" -ForegroundColor White
`;
    return [{ name: 'Deploy-ApimPolicies.ps1', content: ps1, type: 'powershell' }];
  }

  getOutputManifest() {
    return { adapterId: 'apim', adapterName: 'Azure API Management', timestamp: new Date().toISOString(), modulesUsed: ['ISL-01'] };
  }

  _generateGuide(catalog) {
    return `# APIM Deployment Guide
> Generated by ISL Implementation Accelerator | ${new Date().toISOString().slice(0, 10)}

## API Naming Standard
- **Pattern:** \`${catalog.namingStandard.pattern}\`
- **Casing:** ${catalog.namingStandard.casing}
- **Versioning:** ${catalog.namingStandard.versioningStrategy}

## Security Profile
- **Auth:** ${catalog.securityProfile.authMethod}
- **Rate Limit:** ${catalog.securityProfile.rateLimit} req/min
- **mTLS:** ${catalog.securityProfile.mTlsRequired ? 'Required' : 'Not required'}

## Deployment Steps
1. Review all policy XML files in configs/
2. Run Deploy-ApimPolicies.ps1 with -WhatIf
3. Verify policies in Azure Portal
4. Test with sample API calls
`;
  }
}
window.ISL.ApimAdapter = ApimAdapter;
})();
